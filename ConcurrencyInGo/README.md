# Concurrency in Go

## 동시성이 어려운 이유
- **레이스 컨디션**<br>
대부분 이 문제는 하나의 동시 작업이 어떤 변수를 읽으려고 시도하는 동안 또 다른 동시 작업이 특정할 수 없는 시점에 동일 변수에 값을 쓰려고 하는 데이터 레이스인 것으로 밝혀졌다.<br><br>
대부분의 데이터 레이스는 개발자가 문제를 순차적으로 생각하기 때문에 일어난다. 개발자들은 어떤 한 줄의 코드가 다른 코드보다 먼저 나타나기 때문에 먼저 실행될 것이라고 가정한다.<br><br>
레이스 컨디션은 동시성 버그 중 가장 은밀한 유형 중 하나다. 코드가 운영 환경에 투입된 후에도 수년 동안 드러나지 않을 수 있기 때문이다. 그러다가 코드가 실행되는 환경의 변화로 인해 갑작스럽게 버그가 발생한다.

- **원자성**<br>
무언가가 원자적이거나 원자적인 속성을 가진다면, 이는 동작하는 컨텍스트 내에서 나누어지거나 중단되지 않는다는 것을 의미한다. 이때 가장 중요한 것은 컨텍스트라는 용어이다. 어떤 컨텍스트에서는 원자적인 것이 다른 컨텍스트에서는 아닐 수 있다.<br><br>
`i++` 는 간단한 예제이지만 원자성의 개념을 쉽게 보여준다. 이 예시가 원자적으로 보일 수도 있지만, 간단한 분석을 통해 몇 가지 연산으로 구성돼 있음을 알 수 있다.

    - i의 값을 가져온다.
    - i의 값을 증가시킨다.
    - i의 값을 저장한다.<br><br>

    이런 각 연산은 원자적이지만, 세 연산의 조합은 컨텍스트에 따라 원자적이지 않을 수 있다. 즉, 원자적 연산을 조합한다고해서 반드시 더 큰 원자적 연산이 생성되는 것은 아니라는 점이다. 연산을 원자적으로 만드는 것은 사용자가 어떤 컨텍스트에서 원자성을 얻고자 하는지에 달려 있다.<br><br>
    원자 성이 중요한 이유는 무언가가 원자적이라면 암묵적으로 동시에 실행되는 컨텍스트들 내에서는 안전하다는 것을 의미하기때문이다.

- **메모리 접근 동기화**<br>
프로그램에서 공유 리소스에 독점적으로 접근해야 하는 영역을 칭하는 이름이 있는데 이를 임계 영역이라고 한다. 이 임계 영역을 발견하면 메모리에 대한 접근을 동기화하기 위한 (Mutex와 같은)포인트를 추가하라. 꽤 간단해보이는 방법이지만 이것이 데이터 레이스나 논리적인 정확성을 자동으로 해결하지는 못한다. 또한 이 방식이 유지 관리 및 성능 문제를 일으킬 수도 있다.

- **데드락**<br>
프로그램이 데드락 상태에 빠지면, 해당 프로그램에서 동시에 실행 중인 모든 프로세스는 자신이 아닌 다른 프로세스가 끝나기만을 기다린다. 데드락 상태가 되면 외부 개입이 없이는 결코 프로그램을 복구할 수 없다.<br><br>
데드락의 정의를 확실히 하기 위해 아래 예제를 살펴보자.

    ```go
    type value struct {
        mu sync.Mutex
        value int
    }

    var wg sync.WaitGroup
    printSum := func(v1, v2 *value) {
        defer wg.Done()
        v1.mu.Lock()
        defer v1.mu.Unlock()

        time.Sleep(2*time.Second)
        v2.mu.Lock()
        defer v2.mu.Unlock()

        fmt.Printf("sum=%v\n", v1.value + v2.value)
    }

    var a, b value
    wg.Add(2)
    go printSum(&a, &b)
    go printSum(&b, &a)
    wg.Wait()
    ```
    첫번째 printSum 호출은 a를 잠근 다음 b를 잠그려고 시도하지만, 그 사이에 두 번째 printSum 호출이 b를 잠그고 a를 잠그려고 시도했다. 두 고루틴은 서로를 무한히 기다린다.

- **라이브락**<br>

- **기아상태**<br>

- **동시실행 안정성 판단**<br>

## 복잡성 속의 단순함
예를 들어, 웹 서버를 작성하는 데 수락된 모든 연결이 다른 모든 연결과 동시에 처리되도록 하고 싶다고 가정해보자. 일부 언어에서는 웹 서버가 연결 수락을 시작하기 전에 일반적으로 스레드 풀이라고 하는 스레드 컬렉션을 만든 다음, 들어오는 연결을 스레드로 매핑해야한다. 그런 다음, 생성한 각 스레드 내에서 해당 스레드의 모든 연결을 돌면서 그들이 모두 CPU 시간을 할당 받을 수 있도록 해야 한다. 게다가 다른 연결과 공평하게 공유할 수 있도록 연결을 처리하는 논리를 중간에 멈출 수 있도록 작성해야한다.<br><br>
이와는 달리 Go에서는 함수를 작성한 다음, 이를 호출할 때 앞에 go 키워드를 추가하면 된다. 그러면 런타임이 앞서 논의한 모든 것을 자동으로 처리한다!